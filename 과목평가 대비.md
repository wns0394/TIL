# 과목평가 대비

## 1. 파이썬 기초

문장을 구분할 때 들여쓰기(space키 4번) 사용

반드시 한 종류의 들여쓰기만 사용



### 변수

- 컴퓨터 메모리 어딘가에 저장되어 있는 객체를 참조하기 위해 사용되는 이름
  - 객체(object) : 숫자, 문자, 클래스 등 값을 가지고 있는 모든것
  - 파이썬은 객체지향언어, 모든것이 객체로 구현되어있음
- 동일 변수에 다른 객체를 언제든 할당할 수 있기 때문에 즉 참조하는 객체가 바뀔 수 있기 때문에 변수라고 불림
- 변수는 할당연산자(=)를 통해 값을 할당(assignment)
- type() : 변수에 할당된 값의 타입
- id() : 변수에 할당된 값의 고유한 아이덴티티값이며 메모리주소
- 변수의 연산은 숫자끼리는 계산 문자 + 문자는 붙여서 나온다 문자 * 숫자는 문자를 여러번 반복
- 변수는 같은값을 동시에 할당간으 다른값을 동시에 ㅎ할당 가능



### 식별자

True False and or assert async await break class continue def del elif if else 등등은 식별자로 사용불가능



### 자료형 분류

- 불린형(Boolean Type) : True / False 값을 가진 타입 0은 False 1은 True
- 수치형(Numeric Type)
  - int(정수)
  - float(부동소수점, 실수) 값비교 잘하기 import math math.isclose(a,b) 사용
  - complex(복소수) a.real 실수부 a.imag 허수부
- 문자열(String Type) 모든 문자는 str타입 문자열은 immutable(바꿀수없고) lterable(반복가능)
  - Escape sequence `\n`:줄바꿈 `\t`:탭 `\\`:\ `\'`: ' `\"` : "
  - 문자열을 변수로 활용하여 만드는법
    - %-formatting
    - str.format()
    - f-strings
- None : 값이 없음을 표현하기 위해



### 컨테이너

- 여러 개의 값을 담을 수 있는 것(객체)으로, `서로 다른 자료형을 저장`할 수 있음 예시) List, Tuple
- 컨테이너는 순서가 있는 데이터 vs 순서가 없는 데이터
- 여기서 순서가 있다 != 정렬되어있다.



### 컨테이너 분류

- 시퀀스 형
  - 리스트(가변형 mutable)
  - 튜플(불변형 immutable)
  - 레인지(불변형 immutable)
- 비시퀀스 형
  - 세트(가변형 mutable)
  - 딕셔너리(가변형 mutable)



### 리스트

- 순서를 가지는 0개 이상의 객체를 참조하는 자료형
  - 생성된 이후 내용 변경이 가능 -> mutable

- 대괄호 형태로 출력
- list[i]
- 인덱스는              0  1  2   3  4 
- negative index  -5 -4 -3 -2  -1



### 튜플(Tuple)

- 순서를 가지는 0개 이상의 객체를 참조하는 자료형
  - 생성된 이후 담고있는 객체 변경이 불가 - > immutable
- 항상 소괄호 형태로 출력
- 단일 항목의 경우 튜플은 생성 시 값 뒤에 쉼표를 붙여야함

```python
a = 1,
print(a)
print(type(a))
>>>
(1,)
<class 'tuple'>

b = 1,2,3
print(b)
print(type(b))
>>>
(1, 2, 3)
<class 'tuple'>
```



### 레인지(Range)

- 숫자의 시퀀스를 나타내기 위해 사용

  - 기본형 : range(n) : 0부터 n-1까지의 숫자의 시퀀스

  - 범위지정 range(n,m) : n부터 m-1까지의 숫자의 시퀀스
  - 범위 및 스템 지정 range(n,m,s) : n부터 m-1까지 s만큼 증가시키며 숫자의 시퀀스

- ​	???? list(range(6,1,-1)) >>> [6,5,4,3,2]     why?? 6부터 0까지 -1씩 증가 아닌가



### 패킹/언패킹

- 모든 시퀀스형(리스트,튜플,레인지)은 패킹/언패킹 연산자를 사용하여 객체의 패킹 또는 언패킹이 가능

```python
x, *y = 1, 2, 3, 4
print(x)
type(x)
>>>
1
int
print(y)
type(y)
>>>
[2, 3, 4]
list

```

- 패킹의 경우 리스트로 대입 언패킹의 경우 튜플 형태로 대입



### 셋(Set)

- 순서없이 0개 이상의 해시가능한 객체를 참조하는 자료형
  - 해시 가능한 객체(immtable)만 담을 수 있음
- 담고있는 객체를 삽입 변경, 삭제 가능 -> 가변자료형(mutable)
- 수학에서의 집합과 동일한 구조를 가짐
  - 집합 연산이 가능
  - **중복된 값이 존재하지 않음**
- 빈셋을 만드려면 반드시 set()을 해야함 그냥 {}하면 이거는 딕셔너리다
- 순서가 없어 인덱스 접근 등 특정 값에 접근할 수 없음



### 딕셔너리(Dictionary)

- 순서 없이 키-값(key-value)쌍으로 이뤄진 객체를 참조하는 자료형
- key : 해시가능한 불변 자료형만 가능  immtable만 활용가능
- 각 키의 값(value) : 어떠한 형태든 관계 없음



### 연산자

- 산술연산자

| 연산자 |                내용                 |
| :----: | :---------------------------------: |
|   +    |                덧셈                 |
|   -    |                뺄셈                 |
|   *    |                곱셈                 |
|   /    | 나눗셈( 나눗셈은 항상 결과가 float) |
|   //   |                 몫                  |
|   **   |              거듭제곱               |
|   %    |               나머지                |

- 비교연산자 : 값을 비교하여 True/False 값을 리턴함

| 연산자 |            내용             |
| :----: | :-------------------------: |
|   <    |            미만             |
|   <=   |            이하             |
|   >    |            초과             |
|   >=   |            이상             |
|   ==   |            같음             |
|   !=   |          같지않음           |
|   is   |    객체 아이덴티티(OOP)     |
| is not | 객체 아이덴티티가 아닌 경우 |

- 논리 연산자

| 연산자  |             내용              |
| :-----: | :---------------------------: |
| A and B |    A와 B모두 True시, True     |
| A or B  |   A와 B모두 False시, False    |
|   Not   | True를 False로 False를 True로 |

-  논리 연산자 단축평가
  - 결과가 확실한 경우 두번째 값은 확인하지 않고 첫번째 값 반환
    - and 연산에서 첫번째값이 False인 경우 무조건 False => 첫번째값 반환
    - or 연산에서 첫번째 값이 True인 경우 무조건 True => 첫번째값 반환

```python
a = 5 and 4
print(a)
>>> 4

b = 5 or 3
print(b)
>>> 5

c = 0 and 3
print(c)
>>> 0

d = 5 or 0
print(d)
>>> 5
```



### 슬라이싱

- 시퀀스를 특정 단위로 슬라이싱
- s[2:5] -> 'cde'  이거는 index 2 부터 5-1 = 4 까지
- s[:3] -> 'abc'  index 0부터 3-1(2) 까지
- s[5:] index 5부터 끝까지
- s[::] 는 s[0:len(s):1] 와 동일
- s[::-1] 은 역순   s[-1:-(len(s)+1):-1]  과 동일



## 2. 제어문

### 반복문

- while 문
  - 종료조건에 해당하는 코드를 통해 반복문을 종료시켜야함
- for 문
  - 반복가능한 객체를 모두 순회하면 종료( 별도의 종료조건이 필요없음)



### While 문

- 조건식이 참인 경우 반복적으로 코드를 실행
- 종료조건이 반드시 필요



### For 문

- 시퀀스(string, tuple, list, range)를 포함한 순회가능한 객체(iterable)요소를 모두 순회함
  -  처음부터 끝까지 모두 순회하므로 별도의 종료조건이 필요하지  않음
- For 문 일반 형식
  - iterable 순회할 수 있는 자료형(str, dict 등) 순회형 함수(range, enumerate)
  - 딕셔너리는 기본적으로 key를 순회하며, key를 통해 값을 활용
  - 추가 메서드를 활용하여 순회할 수 있음
    - keys(): key로 구성된 결과
    - values() : value로 구성된 결과
    - items() : (key, value)의 튜플로 구성된 결과
- enumerate()
  - 인덱스와 객체를 쌍으로 담은 열겨형(enumerate)객체 반환
  - (index, value) 형태의 tuple로 구성된 열거 객체를 반환



### 반복문 제어

- break : 반복문을 종료
- continue : continue이후의 코드 블록은 수행하지 않고, 다음 반복을 수행
- for-else : 끝까지 반복문을 실행한 이후에 else문 실행
  - break를 통해 중간에 종료되는 경우 else문은 실행되지 않음



## 3. 함수

return 은 하나의 값만 반환한다

return문을 한번만 사용하면서 두개 이상의 값을 반환하는 방법은??? >>> 반환값으로 튜플 사용 예를 들어서 return x-y, x+y

값을 반환하는거 이외에도 함수를 빠져나가는 용도도 있다

parameter : 함수를 실행할 때 함수 내부에서 사용되는 식별자

argument : 함수를 호출할때 넣어주는 값

#### keyword argument 다음에 Positional Argument를 활용할수없음

키워드 인자 다음에 위치인자를 활용할수없음

키워드 인자는 패킹 언패킹할때 **

위치인자는 패킹 언패킹할때 *



### 이름검색 규칙

local scope - enclosed scope - global scope - built in scope



### lambda함수

표현식을 계산한 결과값을 반환하는 함수 익명함수라고도 부름

return문을 가질 수 ㅅ없음 간편 조건문 외 조건문이나 반복문을 가질 수 없음



### 재귀함수

자기 자신을 호출하는 함수

변수 사용이 줄어들며 코드의 가독성이 높아짐



## 모듈

- 모듈
  - 특정 기능을 하는 코드를 파이썬 파일(.py) 단위로 작성한 것
- 패키지
  - 특정 기능과 관련된 여러 모듈의 집합
  - 패키지 안에는 또 다른 서브 패키지 포함



- 모듈과 패키지 불러오기
  - import modul
  - form modul import var, function, Class
  - from module import *
  - ,
  - from package import module
  - from package.module import var, function, class



## 데이터 구조

- 순서가 있는 데이터 구조
  - 문자열(String) 
  - 리스트(List)
  - 튜플(Tuple)
- 순서가 없는 데이터 구조
  - 셋(Set)
  - 딕셔너리(Dictionary)



### 문자열

- 문자열 조회/ 탐색 및 검증 메소드

|    문법     |                             설명                             |
| :---------: | :----------------------------------------------------------: |
|  s.find(x)  |            x의 첫번째 위치를 반환 없으면 -1 반환             |
| s.index(x)  |           x의 첫번째 위치를 반환 없으면 오류 발생            |
| s.isalpha() | 알파벳 문자 여부 *단순 알파벳이 아닌 유니코드 상 Letter (한국어도 포함) |
| s.isupper() |                         대문자 여부                          |
| s.islower() |                         소문자 여부                          |
| s.istitle() |                       타이틀 형식 여부                       |

- 문자열 변경 메소드

|             문법             |                    설명                    |
| :--------------------------: | :----------------------------------------: |
|  s.replace(old,new[,count])  | 바꿀 대상 글자를 새로운 글자로 바꿔서 반환 |
|       s.strip([chars])       |         공백이나 특정 문자를 제거          |
|       s.split([chars])       |     공백이나 특정 문자를 기준으로 분리     |
| 'separator'.join([iterable]) |          구분자로 iterable을 합침          |
|        s.capitalize()        |        가장 첫번째 글자를 대문자로         |
|          s.title()           |          '나 공백 이후를 대문자로          |
|           s.upper            |                모두 대문자                 |
|          s.lower()           |                모두 소문자                 |
|         s.swapcase()         |            대<->소문자 변경하여            |



### 리스트

- 리스트 메소드

|          문법          |                             설명                             |
| :--------------------: | :----------------------------------------------------------: |
|      L.append(x)       |                 리스트 마지막에 항목 x 추가                  |
|     L.insert(i,x)      |               리스트 인덱스 i 에 항목 x를 삽입               |
|      L.remove(x)       | 리스트 가장 왼쪽에 있는 항목(첫번째) x를 제거<br /> 항목이 존재하지 않을 경우, **Value Error** |
|        L.pop()         |    리스트 가장 오른쪽에 있는 항목(마지막)을 반환 후 제거     |
|        L.pop(i)        |        리스트의 인덱스 i 에 있는 항목을 반환 후 제거         |
|      L.extend(m)       | 순회형 m 의 모든 항목들의 리스트 끝에 추가 (+=과 같은 기능)  |
| L.index(x, start, end) | 리스트에 있는 항목 중 가장 왼쪽에 있는 항ㅁ고 x 의 인덱스를 반환 |
|      L.reverse()       |                     리스트를 거꾸로 정렬                     |
|        L.sort()        |               리스트를 정렬(매개변수 이용가능)               |
|       L.count(x)       |      리스트에서 항목 x 가 몇 개 존재하는지 갯수를 반환       |

.extend 

cafe.extend(['coffe']) 하면 'coffe'가 추가되고

cafe.extend('coffe') 하면 'c', 'o', 'f', 'f', 'e' 가 추가된다



- .sort()와 sorted함수 비교
  - .sort()는 원본 변경 sorted는 원본 변경 없음



## OOP

- OOP : 객체지향 프로그래밍
- 객체(object)의 특징
  - 타입(type) : 어떤 연산자(operator)와 조작(method)가 가능한가?
  - 속성(attribute) : 어떤 상태(데이터)를 가지는가?
  - 조작법(method): 어떤 행위(함수)를 할 수 있ㄴ느가?
  - 객체(object) = 속성(attribute) + 기능(method)



- 객체지향의 장점
  - 프로그램을 유연하고 변경이 용이하게 만들어준다
  - 소프트웨어 개발과 보수를 간편하게 하며 직관적인 코드 분석을 가능하게 한다



- 객체 비교하기
  - == 동등한
  - is 동일한



### 인스턴스

- 인스턴스 변수란?
  - 인스턴스가 개인적으로 가지고 있는 속성(attribute)
  - 각 인스턴스들의 고유한 변수
- 생성자 메소드에서 self.<name>으로 정의
- 인스턴스가 생성된 이후<instance>.<name>으로 접근 및 할당



- 인스턴스 메소드
  - 인스턴스 변수를 사용하거나 인스턴스 변수에 값을 설정하는 메소드
  - 클래스 내부에 정의되는 메소드의 기본
  - 호출 시 첫번째 인자로 인스턴스 자기자신(self)이 전달됨
- self
  - 인스턴스 자기자신

- `__init__` : 생성자 메소드, `__del__`:소멸자 메소드





### 클래스

-  클래스 변수
  - 한클래스의 모든 인스턴스라도 똑같은 값을 가지고 있는 속성
  - 클래스 선언 내부에서 정의
- 클래스 메소드
  - 클래스가 사용할 메소드 @classmethod 사용하여 정의
  - 호출시 첫번째 인자로 클래스(cls)가 전달됨
- 스태틱메소드
  - 인스턴스 변수 클래스 변수를 전혀 다루지 않는 메소드
  - 속성을 다루지않고 단지 기능만을 하는 메소드를 정의할때 사용
  - @staticmethod 사용하여 정의
  - 호출시 어떠한 인자도 전달되지 않음(클래스 정보에 접근/ 수정 불가)



### 상속

- super() : 자식클래스에서 부모클래스를 사용하고 싶은 경우
- 파이썬의 모든 클래스는 object로부터 상속됨
- 부모 클래스의 모든 요소(속성,메소드)가 상속됨
- super()를 통해 부모 클래스의 요소를 호출할 수있음
- 메소드 오버라이딩을 통해 자식클래스에서 재정의 가능함
- 상속관계에서의 이름공간은 인스턴스, 자식클래스, 부모 클래스 순으로 탐색



### getter 메소드와 setter 메소드

- 변수에 접근할 수 있는 메소드를 별도로 생성
  - getter 메소드 : 변수의 값을 읽는 메소드
    - @property 데코레이터 사용
  - setter 메소드 : 변수의 값을 설정한느 성격의 메소드
    - @변수.setter 사용
